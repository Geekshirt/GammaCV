webpackJsonp([67],{509:function(e,n){e.exports=[{type:"heading",children:["Get Started"],depth:1},{type:"paragraph",children:["The library is a high-level abstraction API to create and run operations on different backends (WebGL, WASM, JS). GammaCV also enables you to construct operation graphs and control the flow of execution."]},{type:"space",children:[]},{type:"heading",children:["Installation"],depth:2},{type:"paragraph",children:["To use GammaCV you first need to install it. \nTo install the latest stable version run:\n",{type:"codespan",children:"npm install gammacv --save"}]},{type:"space",children:[]},{type:"heading",children:["Core Concepts"],depth:2},{type:"paragraph",children:["To use GammaCV, you need to understand three core concepts: tensors, operations, and sessions. The basic unit of this library is a tensor. ",{type:"codespan",children:"Tensor"}," allows you to create N-dimensional vector and store it in memory using TypedArrays. The second part of the library is an operation. ",{type:"codespan",children:"Operation"}," under the hood is graph node which will have multiple inputs and always produce a single output. The third component is a session. ",{type:"codespan",children:"Session"}," is a runtime which allows you to run computational graphs on different backends with the same API. For a better understanding of how it works let's create a simple program and run it on the GPU using WebGL:"]},{type:"space",children:[]},{type:"code",children:"const imgURL = 'https://source.unsplash.com/random/500x400';\nconst width = 500;\nconst heigth = 400;\n\n// load image from URL or base64 string and store a result in input tensor\ngm.imageTensorFromURL(imgURL, 'uint8', [heigth, width, 4], true).then((input) => {\n  // use the image tensor as the input for the sobelOperator operation\n  // operations return a compiled operation instance\n  const operation = gm.sobelOperator(input);\n\n  // create the tensor for operation output\n  const output = gm.tensorFrom(operation);\n\n  // then we need to create Session which will run created\n  // graph using GPU power and read result to output tensor\n  const sess = new gm.Session();\n  // then you should init operation for current session\n  sess.init(operation);\n  // and finaly for visualize result we need create canvas\n  const canvas = gm.canvasCreate(width, heigth);\n\n  document.body.appendChild(canvas);\n  sess.runOp(operation, 0, output);\n\n  gm.canvasFromTensor(canvas, output);\n});",lang:"JS"},{type:"heading",children:["Chaining / Pipelining operations"],depth:2},{type:"paragraph",children:["For real world applications, you'll often need to combine multiple operations in sequence. With GammaCV this is as easy as creating a pipeline. This is just a semantic nuance, if you've followed the example above, you've already created one."]},{type:"space",children:[]},{type:"code",children:"import * as gm from 'gammacv';\n\nconst imgURL = 'https://source.unsplash.com/random/500x400';\nconst width = 500;\nconst heigth = 400;\n\n// load image from URL or base64 string and store a result in input tensor\ngm.imageTensorFromURL(imgURL, 'uint8', [heigth, width, 4], true).then((input) => {\n  // the input is already a valid operation that can be chained\n  // notice the use of 'let'. We are going to reuse the pipeline variable\n  let pipeline = input\n\n  // operations always return a valid input for another operation.\n  // if you are a functional programmer, you could easily compose these.\n  pipeline = gm.grayscale(pipeline);\n  pipeline = gm.gaussianBlur(pipeline, 3, 3);\n  pipeline = gm.sobelOperator(pipeline);\n  pipeline = gm.cannyEdges(pipeline, 0.25, 0.75);\n\n  // allocate output tensor\n  const output = gm.tensorFrom(pipeline);\n  const sess = new gm.Session();\n\n  sess.init(pipeline);\n\n  // run your operation\n  sess.runOp(pipeline, 0, output);\n\n  // display your output\n  const canvasOriginal = gm.canvasCreate(width, heigth);\n  const canvasProcessed = gm.canvasCreate(width, heigth);\n\n  document.body.appendChild(canvasOriginal);\n  document.body.appendChild(canvasProcessed);\n  gm.canvasFromTensor(canvasOriginal, input);\n  gm.canvasFromTensor(canvasProcessed, output);\n});",lang:"JS"},{type:"heading",children:["Run fast real time processing"],depth:2},{type:"code",children:"import * as gm from 'gammacv';\n\nconst width = 500;\nconst heigth = 400;\n// initialize WebRTC stream and session for runing operations on GPU\nconst stream = new gm.CaptureVideo(width, heigth);\nconst sess = new gm.Session();\nconst canvasProcessed = gm.canvasCreate(width, heigth);\n\n// session uses a context for optimize calculations and prevent recalculations\n// context actually a number which help algorythm to run operation efficiently  \nlet context = 0;\n// allocate memeory for storing a frame and calculations output\nconst input = new gm.Tensor('uint8', [heigth, width, 4]);\n// construct operation grap which is actially a Canny Edge Detector\nlet pipeline = input\n\npipeline = gm.grayscale(pipeline);\npipeline = gm.gaussianBlur(pipeline, 3, 3);\npipeline = gm.sobelOperator(pipeline);\npipeline = gm.cannyEdges(pipeline, 0.25, 0.75);\n\n// initialize graph\nsess.init(pipeline);\n\n// allocate output\nconst output = gm.tensorFrom(pipeline);\n\n// create loop\nconst tick = () => {\n  requestAnimationFrame(tick);\n  // Read current in to the tensor\n  stream.getImageBuffer(input);\n\n  // finaly run operation on GPU and then write result in to output tensor\n  sess.runOp(pipeline, context, output);\n\n  // draw result into canvas\n  gm.canvasFromTensor(canvasProcessed, output);\n\n  // if we would like to be graph recalculated we need \n  // to change the context for next frame\n  context += 1;\n}\n\n// start capturing a camera and run loop\nstream.start();\ntick();\n\ndocument.body.appendChild(stream.canvas);\ndocument.body.appendChild(canvasProcessed);",lang:"JS"}]}});